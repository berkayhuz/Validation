<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Web.Extensions" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Web.Script.Serialization" #>
<#@ import namespace="System.Collections.Generic" #>


<#
    var jsonPath = Path.Combine(Path.GetDirectoryName(Host.TemplateFile), "validators.json");
    var json = File.ReadAllText(jsonPath);
    var validators = new JavaScriptSerializer().Deserialize<List<ValidatorModel>>(json);

var requiredUsings = new HashSet<string>
{
    "Microsoft.AspNetCore.Http",
    "FluentValidation",
    "Validation.Core.Validators.Common",
    "Validation.Core.Validators.Date",
    "Validation.Core.Validators.Format",
    "Validation.Core.Validators.Localization",
    "Validation.Core.Validators.Logic",
    "Validation.Core.Validators.Network",
    "Validation.Core.Validators.Numeric",
    "Validation.Core.Validators.Security"
};


    foreach (var v in validators)
    {
        foreach (var p in v.Parameters ?? new List<ValidatorParameter>())
        {
            if (p.Type.Contains("RegexOptions"))
                requiredUsings.Add("System.Text.RegularExpressions");
            if (p.Type.Contains("IFormFile"))
                requiredUsings.Add("Microsoft.AspNetCore.Http");
            if (p.Type.Contains("Func"))
                requiredUsings.Add("System");
            if (p.Type.Contains("TimeOnly") || p.Type.Contains("DateOnly"))
                requiredUsings.Add("System");
        }
    }
#>
// <auto-generated>
namespace Validation.Core.Extensions;
<#
foreach (var u in requiredUsings.OrderBy(x => x))
{
#>
using <#= u #>;
<#
}
#>

public static partial class RuleBuilderExtensions
{
<#
    foreach (var v in validators)
    {
        var paramSignature = string.Join(", ", v.Parameters?.ConvertAll(p =>
        {
            var nullable = p.Nullable ? "?" : "";
            var def = !string.IsNullOrWhiteSpace(p.DefaultValue) ? $" = {p.DefaultValue}" : "";
            return $"{p.Type}{nullable} {p.Name}{def}";
        }) ?? new List<string>());

        var callArgs = !string.IsNullOrWhiteSpace(v.CustomConstructorArgs)
            ? v.CustomConstructorArgs
            : string.Join(", ", v.Parameters?.ConvertAll(p => p.Name) ?? new List<string>());

        var needsParams = !string.IsNullOrWhiteSpace(paramSignature);

        // Method name with proper generic suffix, if needed
        var returnType = v.ValueType;
        var methodName = v.MethodName;
        var validatorType = v.ValidatorType;
#>
        public static IRuleBuilderOptions<T, <#= returnType #>> <#= methodName #><<#= ExtractGenericArguments(validatorType) #>>(
        this IRuleBuilder<T, <#= returnType #>> ruleBuilder<#= needsParams ? ", " + paramSignature : "" #>)
        => ruleBuilder.SetValidator(new <#= validatorType #>(<#= callArgs #>));
<#
    }
#>
}

<#+
public class ValidatorModel
{
    public string MethodName { get; set; }
    public string ValidatorType { get; set; }
    public string ValueType { get; set; }
    public List<ValidatorParameter> Parameters { get; set; }
    public string CustomConstructorArgs { get; set; }
}

public class ValidatorParameter
{
    public string Name { get; set; }
    public string Type { get; set; }
    public bool Nullable { get; set; }
    public string DefaultValue { get; set; }
}

private string ExtractGenericArguments(string validatorType)
{
    if (!validatorType.Contains("<") || !validatorType.Contains(">"))
        return "T";

    var inner = validatorType.Substring(validatorType.IndexOf('<') + 1);
    inner = inner.Substring(0, inner.LastIndexOf('>'));
    return inner.Trim();
}

#>
